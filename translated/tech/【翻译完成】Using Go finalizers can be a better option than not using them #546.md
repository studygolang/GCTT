    Go拥有finalizers，它们支持程序调用一些代码并作为一个对象来进行垃圾回收。然而，很多人不太喜欢finalizers，并且通常的建议是完全避免它们([比如](https://twitter.com/davecheney/status/790343722865090560))。最近，David Crawshaw 在[《Finalizers惨案》](https://crawshaw.io/blog/tragedy-of-finalizers)一文中指出finalizers的众多弊端并展示一个依赖他们会导致失败的案例。我差不多同意其上述所有观点，但与此同时，我自己已经在[一个Go包访问Solaris/Illumos kstats](https://github.com/siebenmann/go-kstat)中使用finalizers，接下来我将对此用法进行辩护。
    我使用finalizers来避免人们不正确使用[我的API](https://github.com/siebenmann/go-kstat/blob/master/kstat-godoc.txt)时造成不可见的内存泄露。理论上，当你调用我的jar包并返回一个神奇的token，它持有对一些C-allocated内存的唯一引用。当你使用此token后，你应该调用一个方法关闭它，以此来释放C-allocated内存。通常人们会在API用法和对象生命周期上犯错。在不使用finalizer的情形下，如果一个token超过作用范围并在垃圾回收中未被回收，我们将永久泄露此C-allocated内存。诸如所有内存和资源泄露此类事情，这将成为一个极其容易忽视且致命的泄露，因为从Go标准上它将完全不可见。目前也没有任何一个通用Go标准内存泄露工具帮助你解决上述问题（且鉴于Go的存在，我认为通用C泄露查找工具会产生严重的问题）。
    一方面，此处使用一个finalizer是一种实用的决定；它能保障人们在使用我的jar包时，远离某些用法错误，这些错误会造成一些难以解决的问题。另一方面，我认为此处使用finalizers正是Go的广泛意义所在。作为一门垃圾回收语言，Go从本质上决定了管理对象生命周期过于困难，需要大量工作，且太容易犯错。使用finalizer完美处理内存问题是存在一定特殊性的，但并不适用于处理除纯粹从实用角度出发之外的任何其他资源。
    （与此同时，这些实用角度是真实存在的;正如David Crawshaw所言，依赖内存垃圾回收来垃圾收集被耗尽之前的其他资源是极其危险的。这一点甚至对于我的示例在某种程度上也是值得怀疑的，因为C-allocated内存并未施压于Go垃圾回收器。）
    David Crawshaw跟进发表了一篇文章-[《锐利的Go Finalizers》](https://crawshaw.io/blog/sharp-edged-finalizers),这篇文章中他主张，当人们不能正确使用你的APIs时使用finalizers来强制恐慌。你可以这么干，但对我来说这有点不像Go的风格。总之我认为当且仅当不正确使用你的API的后果是特别严重的话，你才应该采用这种方式（比如说，潜在的数据丢失，由于你忘了提交数据库事务然后检查出错误）。
    一般而言，我不认为我这种finalizers使用方式本身是有意去避免泄漏的。通常从你不再需要这些资源（kstat令牌，开放文件，或者你拥有的资源）那一刻起，程序将发生内存泄漏，直到Go垃圾回收调用你的finalizer（如果之前是这么干的话），因为这些资源一直都存在，但没有一个在被使用或需要。finalizers所做的就是让这些泄漏从理论上成为暂时，而不是明确地永久。换句话说，这是一个可修复的泄漏而不是不可修复的泄漏。
    PS:此观点当然不是我原创的。比如说，[非官方Go FAQ](https://go101.org/article/unofficial-faq.html)阐述[finalizers的主要用途](https://go101.org/article/unofficial-faq.html#finalizers)，且有标准库中*os.File finalizer的例子。
    （此观点已经在我脑海中有一段时间了，但David Crawshaw的文章提供了一个便捷的提示，而我并没有想到在这种情形下使用finalizers来强制出现一个严重的错误。）